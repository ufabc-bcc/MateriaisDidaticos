\documentclass[Ligatures=TeX,table,brazil,svgnames,usetotalslideindicator,compress,10pt]{beamer}

\usetheme[titleformat=allsmallcaps]{metropolis}

\usepackage{polyglossia}
\setdefaultlanguage{brazil}
\disablehyphenation

\usepackage{minted}

\usetikzlibrary{arrows,positioning,calc}

\usepackage{graphicx}
\graphicspath{{./figuras/}}
\usepackage{subcaption}
\usepackage{xmpmulti}

% \usepackage{textpos}

% \usepackage{mdwlist}
% \usepackage{siunitx}
\usepackage{alltt}
% \usepackage{multicol}
\usepackage{xspace}
\usepackage{multirow}
\usepackage{amsmath}

\usepackage{cancel}

\newcommand{\setcoverbg}{
  \setbeamertemplate{background}
  {\includegraphics[width=\paperwidth,height=\paperheight]{backgrounds/coverbg}}
}
\newcommand{\setintersectionbg}{
  \setbeamertemplate{background}
  {\includegraphics[width=\paperwidth,height=\paperheight]{backgrounds/blank}}
}
\newcommand{\setsectionbg}{
  \setbeamertemplate{background}
  {\includegraphics[width=\paperwidth,height=\paperheight]{backgrounds/slidebg2}}
}

\setbeamertemplate{caption}{default}

\title{MCTA025-13 - Sistemas Distribu√≠dos}
\subtitle{Rel√≥gios Vetoriais, Exclus√£o M√∫tua e Elei√ß√£o}

\author{Emilio Francesquini}
\institute{Centro de Matem√°tica, Computa√ß√£o e Cogni√ß√£o\\ Universidade Federal do ABC}
\date{06 de agosto de 2018}

\begin{document}

\setcoverbg
\maketitle

\setsectionbg

\begin{frame}
  \frametitle{Disclaimer}
  \begin{itemize}
  \item Estes slides foram preparados para o curso de \textbf{Sistemas
      Distribu√≠dos na UFABC}.
  \item Este material pode ser usado livremente desde que sejam
    mantidos, al√©m deste aviso, os cr√©ditos aos autores e
    institui√ß√µes.
  \item Estes slides foram adaptados daqueles originalmente preparados
    (e gentilmente cedidos) pelo professor \textbf{Daniel Cordeiro, da
      EACH-USP} que por sua vez foram baseados naqueles
    disponibilizados online pelos autores do livro ``Distributed
    Systems'', 3¬™ Edi√ß√£o em:
    \url{https://www.distributed-systems.net}.
  \end{itemize}
\end{frame}


\begin{frame}
  \frametitle{Rel√≥gios L√≥gicos: a rela√ß√£o ``aconteceu-antes''}

  \begin{block}{A rela√ß√£o ``aconteceu-antes'' (\textit{happened-before})}
    \begin{itemize}
    \item se $a$ e $b$ s√£o dois eventos de um mesmo processo e $a$ ocorreu antes de $b$, ent√£o $a \rightarrow b$
    \item se $a$ for o evento de envio de uma mensagem e $b$ for o evento de recebimento desta mesma mensagem, ent√£o $a \rightarrow b$
    \item se $a \rightarrow b$ e $b \rightarrow c$, ent√£o $a \rightarrow c$
    \end{itemize}
  \end{block}

  \begin{alertblock}{Nota:}
    Isso introduz uma no√ß√£o de \alert{ordem parcial dos eventos} em um sistema com processos executando concorrentemente.
  \end{alertblock}

\end{frame}

\begin{frame}
  \frametitle{Rel√≥gio l√≥gico de Lamport}
  \begin{alertblock}{Problema}
    Como fazemos para manter uma vis√£o global do comportamento do sistema que seja consistente com a rela√ß√£o aconteceu-antes?
  \end{alertblock}

  \begin{block}{Solu√ß√£o}
    Associar um \textit{timestamp} $C(e)$ a cada evento $e$ tal que:
    \begin{description}
    \item[P1] se $a$ e $b$ s√£o dois eventos no mesmo processo e $a \rightarrow b$, ent√£o √© obrigat√≥rio que $C(a) < C(b)$
    \item[P2] se $a$ corresponder ao envio de uma mensagem $m$ e $b$ ao recebimento desta mensagem, ent√£o tamb√©m √© v√°lido que $C(a) < C(b)$
    \end{description}
  \end{block}

\end{frame}

\begin{frame}
  \frametitle{Rel√≥gio l√≥gico de Lamport}

  \begin{block}{Solu√ß√£o}
    Cada processo $P_i$ mant√©m um contador $C_i$ \alert{local} e o ajusta de acordo com as seguintes regras:
    \begin{enumerate}
    \item para quaisquer dois \textbf{eventos sucessivos} que ocorrer em $P_i$, $C_i$ √© incrementado em 1
    \item toda vez que uma mensagem $m$ for \alert{enviada} por um processo $P_i$, a mensagem deve receber um \textit{timestamp} $ts(m) = C_i$
    \item sempre que uma mensagem $m$ for \alert{recebida} por um processo $P_j$, $P_j$ ajustar√° seu contador local $C_j$ para \alert{$\max\{C_j, ts(m)\}$} e executar√° o passo 1 antes de repassar $m$ para a aplica√ß√£o
    \end{enumerate}
  \end{block}

  \begin{block}{Observa√ß√µes:}
    \begin{itemize}
    \item a propriedade \textbf{P1} √© satisfeita por (1); propriedade \textbf{P2} por (2) e (3)
    \item ainda assim pode acontecer de dois eventos ocorrerem ao mesmo tempo. \alert{Desempate usando os IDs dos processos}.
    \end{itemize}
  \end{block}

\end{frame}


\begin{frame}
  \frametitle{Rel√≥gio L√≥gico - Exerc√≠cio}
  {\centering
    \vspace{-4em}
    \includegraphics[width=\textwidth]{lamp1}\\
    \vspace{-6em}
  \footnotesize{Fonte: CDKB}
}

\alert{\textbf{Exerc√≠cio:}} O que se pode dizer sobre:
\begin{enumerate}
\item \textbf{a} e \textbf{b}?
\item \textbf{b} e \textbf{c}?
\item \textbf{a} e \textbf{f}?
\item \textbf{a} e \textbf{e}?
\end{enumerate}

\end{frame}


\section{Rel√≥gios Vetoriais}

\begin{frame}
  \frametitle{Rel√≥gios vetoriais}
  \begin{block}{Observa√ß√£o:}
    Rel√≥gios de Lamport \textbf{n√£o} garantem que $C(a) < C(b)$ implica que $a$ \alert{tenha realmente ocorrido antes} de $b$:
  \end{block}

  \begin{columns}
    \begin{column}{0.4\textwidth}
      \includegraphics[width=\textwidth]{06-12}
    \end{column}

    \begin{column}{0.5\textwidth}
      \begin{block}{Observa√ß√£o}
        Evento $a$: $m_1$ foi recebido em $T = 16$; \newline
        Evento $b$: $m_2$ foi enviado em $T = 20$.
      \end{block}
    \end{column}
  \end{columns}

  \begin{alertblock}{Nota}
    N√≥s \alert{n√£o podemos} concluir que $a$ precede temporalmente (preced√™ncia causal) $b$.
  \end{alertblock}

\end{frame}

\begin{frame}
  \frametitle{Depend√™ncia causal}
  \begin{block}{Defini√ß√£o}
    Dizemos que $b$ pode depender causalmente de $a$ se $ts(a) < ts(b)$ com:
    \begin{itemize}
    \item para todo $k$, $ts(a)[k] \le ts(b)[k]$ e
    \item existe pelo menos um √≠ndice $k'$ para o qual $ts(a)[k'] < ts(b)[k']$
    \end{itemize}
  \end{block}

  \begin{block}{Preced√™ncia vs.\ depend√™ncia}
    \begin{itemize}
    \item Dizemos que $a$ precede causalmente $b$
    \item $b$ \alert{pode} depender causalmente de $a$, j√° que h√° informa√ß√£o de $a$ que pode ter sido propagada para $b$
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}
  \frametitle{Capturando a causalidade - Rel√≥gios Vetoriais}
  \alert{Rel√≥gios vetoriais foram criados para resolver as limita√ß√µes
    de rel√≥gios de Lamport}, \emph{i.e.}, o fato de que eles
  \textbf{n√£o garantem que se $C(a) < C(b)$ ent√£o $a \rightarrow b$}.

\mbox{}

    \begin{block}{Solu√ß√£o: cada $P_i$ mant√©m um vetor $VC_i$}
      \begin{itemize}
      \item $VC_i[i]$ √© o rel√≥gio l√≥gico local do processador $P_i$
      \item se $VC_i[j] = k$, ent√£o $P_i$ sabe que $k$ eventos ocorreram em $P_j$.
      \end{itemize}
    \end{block}

    \begin{block}{Mantendo os rel√≥gios vetoriais}
      \begin{enumerate}
      \item antes da execu√ß√£o de um evento, $P_i$ executa $VC_i[i] \leftarrow VC_i[i]+1$
      \item quando o processo $P_i$ enviar uma mensagem $m$ para $P_j$, ele define o \textit{timestamp} (vetorial) de m $ts(m)$ como sendo $VC_i$ (ap√≥s executar o passo 1)
      \item no recebimento de uma mensagem $m$, o processo $P_j$ define $VC_j[k] \leftarrow \max\{VC_j[k], ts(m)[k]\}$
      \end{enumerate}
    \end{block}

\end{frame}

\begin{frame}
  \frametitle{Rel√≥gios Vetoriais --- Exemplo}

  \begin{onlyenv}<2>
    Suponha agora um atraso no envio de $m_2$:
  \end{onlyenv}

  \begin{figure}
    \centering
    \includegraphics<1->[width=.46\textwidth]{06-13a}
    \qquad
    \includegraphics<2>[width=.46\textwidth]{06-13b}
  \end{figure}

  \begin{block}{An√°lise}
    \scriptsize
    \begin{tabular}{c|c|c|m{3.5em}|m{3.5em}|l}
      \textbf{Situa√ß√£o} & $ts(m_2)$ & $ts(m_4)$ & $ts(m_2) < ts(m_4)$ & $ts(m_2) > ts(m_4)$ & \textbf{Conclus√£o} \\ \hline \hline
                        (a)&(2,1,0)&(4,3,0)&Sim&N√£o&$m_2$ pode preceder causalmente $m_4$, $m_2 \rightarrow m_4$ \\ \hline \pause
                        (b)&(4,1,0)&(2,3,0)&N√£o&N√£o&$m_2$ e $m_4$ podem conflitar, $m_2 \parallel m_4$\\ \hline
    \end{tabular}
  \end{block}

\end{frame}

\begin{frame}
  \frametitle{Rel√≥gios Vetoriais --- Exerc√≠cio}
  {\centering
    \includegraphics[width=0.9\textwidth]{lamp2}\\
    \vspace{-5em}
    \footnotesize{Fonte: CDKB}
  }

  \alert{\textbf{Exerc√≠cio}}
  \begin{enumerate}
  \item O que pode ser dito sobre \textbf{a} e \textbf{f}?
  \item O que pode ser dito sobre \textbf{c} e \textbf{e}?
  \end{enumerate}

\end{frame}

\begin{frame}
  \frametitle{Aula passada: multicast com ordem total}
  \begin{alertblock}{Problema}
    Alguma vezes precisamos garantir que atualiza√ß√µes concorrentes em um banco de dados replicado sejam vistos por todos como se tivessem ocorrido na mesma ordem.

  \begin{itemize}
  \item $P_1$ adiciona R\$ 100 a uma conta (valor inicial: R\$ 1000)
  \item $P_2$ incrementa a conta em 1\%
  \item H√° duas r√©plicas
  \end{itemize}
\end{alertblock}

\begin{figure}
  \centering
  \includegraphics[scale=0.6]{06-11}
\end{figure}

\vspace{-1ex}
\begin{block}{Resultado}
  Na aus√™ncia de sincroniza√ß√£o correta, \newline r√©plica \#1 $\leftarrow$ R\$ 1111, enquanto que na r√©plica \#2 $\leftarrow$ R\$ 1110.
\end{block}

\end{frame}


\begin{frame}
  \frametitle{Multicast ordenado por causalidade}
  \begin{block}{Observa√ß√£o}
    Agora √© poss√≠vel garantir que uma mensagem seja entregue somente
    \textbf{se todas as mensagens que as procederem por causalidade tiverem
    sido entregues}.

    Multicasts \alert{ordenados por causalidade} \textbf{s√£o menos restritivos}
    do que multicasts \emph{com ordem total}. Se
    duas mensagens n√£o tem uma rela√ß√£o causal, ent√£o a ordem que elas ser√£o
    entregues pode ser \textbf{diferente para cada um dos processos}.
  \end{block}
\end{frame}

\begin{frame}
  \frametitle{Garantido Multicasts Ordenados por Causalidade}

  Para garantir que as mensagens ser√£o entregues seguindo a ordem causal:

  \begin{block}{Passos}
    \begin{enumerate}
    \item $P_i$ incrementa $VC_i[i]$ somente quando enviar uma mensagem;
    \item $P_j$ \alert{``ajusta''} $VC_j$ quando
      \textbf{entregar}\footnote{\textbf{Aten√ß√£o}: as mensagens n√£o
        s√£o ajustadas quando s√£o \emph{recebidas}, mas sim quando elas
        s√£o \emph{entregues} √† aplica√ß√£o} uma mensagem (mas n√£o muda
      $VC_j[j]$): $VC_i[k] = \max\{VC_j[k], ts(m)[k]\}, \forall k$
    \end{enumerate}

  \end{block}

  \pause
  \framebox{\begin{minipage}{0.97\textwidth}
      \alert{Al√©m disto, $P_j$ posterga a \textbf{entrega} de $m$ at√© que}:

      \begin{itemize}
      \item $ts(m)[i] = VC_j[i] + 1$. {\tiny ($m$ √© a pr√≥xima mensagem que $P_j$ espera de $P_i$)}
      \item $ts(m)[k] \leq VC_j[k]$ para $k \neq i$. {\tiny ($P_j$ j√° entregou todas as mensagens enviadas para $P_i$)}
      \end{itemize}
    \end{minipage}}

\end{frame}

\begin{frame}
  \frametitle{Multicast ordenado por causalidade}

  \begin{exampleblock}{Exemplo}
    \centering
    \includegraphics{06-14}
  \end{exampleblock}

  \pause
  \begin{exampleblock}{Exerc√≠cio}
    Tome $VC_3 = [0,2,2]$, $ts(m) = [1,3,0]$ em $P_1$. Que informa√ß√£o $P_3$ tem e o que ele ir√° fazer quando receber $m$ (de $P_1$)?
  \end{exampleblock}

\end{frame}

\section{Algoritmos de Exclus√£o M√∫tua}

\begin{frame}
  \frametitle{Exclus√£o m√∫tua}
  \begin{alertblock}{Problema}
    Alguns processos em um sistema distribu√≠do querem acesso exclusivo a algum recurso.
  \end{alertblock}

  \begin{block}{Solu√ß√µes:}
    \begin{description}
    \item[Baseado em permiss√£o:] um processo que quiser entrar na se√ß√£o cr√≠tica (ou acessar um recurso) precisa da permiss√£o de outros processos
    \item[Baseado em tokens:] um \textit{token} √© passado entre processos. Aquele que tiver o \textit{token} pode entrar na se√ß√£o cr√≠tica ou pass√°-lo para frente quando n√£o estiver interessado.
    \end{description}

    \end{block}

\end{frame}

\begin{frame}
  \frametitle{Baseado em permiss√£o, centralizado}
  \begin{block}{Use um coordenador}
    \begin{figure}
      \centering
      \begin{subfigure}{.3\linewidth}
        \includegraphics{06-15a}
        \caption{}
      \end{subfigure}
      \quad
      \begin{subfigure}{.3\linewidth}
        \includegraphics{06-15b}
        \caption{}
    \end{subfigure}
    \quad
      \begin{subfigure}{.3\linewidth}
        \includegraphics{06-15c}
        \caption{}
      \end{subfigure}
    \end{figure}

    \begin{itemize}
    \item[(a)] Processo $P_1$ pede permiss√£o ao coordenador para acessar o recurso compartilhado. Permiss√£o concedida.
    \item[(b)] Processo $P_2$ ent√£o pede permiss√£o para acessar o mesmo recurso. O coordenador n√£o responde.
    \item[(c)] Quando $P_1$ libera o recurso, avisa o coordenador, que ent√£o responde para $P_2$.
    \end{itemize}
  \end{block}


\end{frame}

\begin{frame}
  \frametitle{Exclus√£o m√∫tua -- Ricart \& Agrawala, Vers√£o Distribu√≠da}
  \begin{block}{Princ√≠pio}
    Mesmo do Lamport, exceto que acks n√£o s√£o enviados. Ao inv√©s disso, respostas (permiss√µes) s√£o enviadas quando:
    \begin{itemize}
    \item o processo receptor n√£o tem interesse no recurso compartilhado; ou
    \item o processo receptor est√° esperando por um recurso, mas tem
      menos prioridade (a prioridade √© determinada via compara√ß√£o de
      timestamps)
    \end{itemize}
  \end{block}

    \begin{block}{}
      Em todos os outros casos, o envio da resposta √© \alert{adiado}, implicando a necessidade de alguma administra√ß√£o local.
    \end{block}
\end{frame}

\begin{frame}
  \frametitle{Exclus√£o m√∫tua -- Ricart \& Agrawala, Vers√£o Distribu√≠da}

  Exemplo com tr√™s processos:

  \begin{figure}
    \centering
    \includegraphics[width=.9\textwidth]{06-15}
  \end{figure}

  \begin{itemize}
  \item[(a)] dois processos ($P_0$ e $P_2$) querem acessar um recurso
    compartilhado ao mesmo tempo
  \item[(b)] $P_0$ tem o menor \textit{timestamp}; ele ganha
  \item[(c)] quando $P_0$ terminar, tamb√©m manda um OK; assim $P_2$ agora pode continuar
  \end{itemize}

\end{frame}

\begin{frame}
  \frametitle{Exclus√£o m√∫tua baseada em token}
   \begin{figure}
    \centering
    \begin{minipage}{0.45\textwidth}
      \centering
      \includegraphics[width=0.9\textwidth]{concha.jpg}\\
      \includegraphics[width=0.9\textwidth]{concha2.png}
    \end{minipage}\hfill
    \begin{minipage}{0.45\textwidth}
        \centering
        \includegraphics[width=\textwidth]{smoscas.jpg}
    \end{minipage}
  \end{figure}
  \centering
  \footnotesize{Fonte: Google Images}
\end{frame}


\begin{frame}
  \frametitle{Exclus√£o m√∫tua: token ring}
  \begin{block}{Ideia}
    Organizar os processos em anel \alert{l√≥gico} e passar um \textit{token} entre eles. Aquele que estiver com o \textit{token} pode entrar na se√ß√£o cr√≠tica (se ele quiser).
  \end{block}

  \begin{figure}
    \centering
    \includegraphics[width=\textwidth]{06-16}
  \end{figure}

\end{frame}

\begin{frame}
  \frametitle{Exclus√£o m√∫tua decentralizada}
  \begin{block}{Princ√≠pio}
    Assuma que todo recurso √© replicado $N$ vezes, com cada r√©plica associada a seu pr√≥prio coordenador  $\Rightarrow$ acesso requer a \alert{maioria dos votos} de $m > N/2$ coordenadores. Um coordenador sempre responde imediatamente a uma requisi√ß√£o.
  \end{block}

  \begin{block}{Hip√≥tese}
    Quando um coordenador morrer, ele se recuperar√° rapidamente, mas ter√° esquecido tudo sobre as permiss√µes que ele deu.
  \end{block}

\end{frame}

\begin{frame}
  \frametitle{Exclus√£o m√∫tua decentralizada}

  \begin{block}{Qu√£o robusto √© esse sistema?}
    \begin{itemize}
      \item Seja $p = \Delta t / T$ a probabilidade de que um coordenador morra e se recupere em um per√≠odo $\Delta t$ e que tenha uma esperan√ßa de vida $T$.
        \item A probabilidade $\mathbb{P}[k]$ de que $k$ dos $m$ coordenadores sejam resetados durante o mesmo intervalo √©:
    \[ \mathbb{P}[k] = \binom{m}{k} p^k (1 - p)^{m-k}\]
  \item $f$ coordenadores resetam $\Rightarrow$ \alert{corretude √© violada quando os coordenadores que n√£o falharam s√£o minoria}: quando $m-f \le N/2$ ou $f \ge m-N/2$
  \item A probabilidade de viola√ß√£o √© $\sum^N_{m-N/2} \mathbb{P}[k]$.
  \end{itemize}
\end{block}
\end{frame}

\begin{frame}
  \frametitle{Exclus√£o m√∫tua decentralizada}

    \begin{block}{Probabilidade de viola√ß√£o em fun√ß√£o dos par√¢metros}
    \begin{center}
      \small\footnotesize
      \renewcommand{\arraystretch}{1.1}
      \begin{tabular}{cc}
        \begin{minipage}{0.4\textwidth}
          \[
          \begin{array}{|c|c|c|c|}\hline
            \mathbf{N}  & \mathbf{m} & \mathbf{p}        & \mbox{\textbf{Viola√ß√£o}} \\ \hline\hline
            8           & 5          & \mbox{3 seg/hora} & < 10^{-15} \\ \hline
            8           & 6          & \mbox{3 seg/hora} & < 10^{-18} \\ \hline
            16          & 9          & \mbox{3 seg/hora} & < 10^{-27} \\ \hline
            16          & 12         & \mbox{3 seg/hora} & < 10^{-36} \\ \hline
            32          & 17         & \mbox{3 seg/hora} & < 10^{-52} \\ \hline
            32          & 24         & \mbox{3 seg/hora} & < 10^{-73} \\ \hline
          \end{array}
          \]
        \end{minipage} &
        \begin{minipage}{0.4\textwidth}
          \[
          \begin{array}{|c|c|c|c|}\hline
            \mathbf{N}  & \mathbf{m} & \mathbf{p}        & \mbox{\textbf{Viola√ß√£o}} \\ \hline\hline
            8           & 5          & \mbox{30 seg/hora} & < 10^{-10} \\ \hline
            8           & 6          & \mbox{30 seg/hora} & < 10^{-11} \\ \hline
            16          & 9          & \mbox{30 seg/hora} & < 10^{-18} \\ \hline
            16          & 12         & \mbox{30 seg/hora} & < 10^{-24} \\ \hline
            32          & 17         & \mbox{30 seg/hora} & < 10^{-35} \\ \hline
            32          & 24         & \mbox{30 seg/hora} & < 10^{-49} \\ \hline
          \end{array}
          \]
        \end{minipage}
      \end{tabular}
    \end{center}
  \end{block}
\end{frame}

\begin{frame}
  \frametitle{Exclus√£o m√∫tua: compara√ß√£o}

  \begin{center}
    \footnotesize
    \renewcommand{\arraystretch}{1.2}
    \begin{tabular}{|l|l|l|l|}\hline
      \alert{Algor√≠timo} 	& \alert{\# msgs por} & \alert{Atraso para entrar} & \alert{Problemas} \\
      & \alert{entrada/sa√≠da} & \alert{(em qde msgs)} & \\ \hline
      Centralizado & 3 & 2 & Morte do coordenador \\ \hline
      Decentralizado & 2mk + m, k = 1,2,... & 2mk & \textit{Starvation}, ineficiente.              \\ \hline
      Distribu√≠do & 2~(n~--~1) & 2~(n~--~1) & Morte de qualquer \\ \hline
      Token ring & 1 √† $\infty$ & 0 √† n~--~1 & Perder token,  proc. morrer\\ \hline
    \end{tabular}
  \end{center}


\end{frame}

\section{Algoritmos de elei√ß√£o}

\begin{frame}
  \frametitle{Algoritmos de elei√ß√£o}
  \begin{block}{Princ√≠pio}
    Um algoritmo precisa que algum dos processos assuma o papel de coordenador. A pergunta √©: como selecionar esse processo especial \alert{dinamicamente}?
  \end{block}

  \begin{block}{Nota}
    Em muitos sistemas o coordenador √© escolhido manualmente (ex: servidores de arquivos). Isso leva a solu√ß√µes centralizadas com um ponto √∫nico de falha.
  \end{block}

  \begin{block}{Perguntas}
    \begin{enumerate}
    \item Se um coordenador √© escolhido dinamicamente, at√© que ponto podemos dizer que o sistema ser√° centralizado e n√£o distribu√≠do?
    \item Um sistema inteiramente distribu√≠do (ou seja, um sem um coordenador) √© sempre mais robusto que uma solu√ß√£o centralizada/coordenada?
    \end{enumerate}
  \end{block}

\end{frame}

\begin{frame}
  \frametitle{Hip√≥teses b√°sicas}
  \begin{itemize}
  \item Todos os processos possuem um \texttt{id} √∫nico
  \item Todos os processos conhecem os \texttt{id}s de todos os outros processos no sistema (mas eles n√£o tem como saber se os n√≥s est√£o funcionando ou n√£o)
  \item A elei√ß√£o significa identificar o processo de maior \texttt{id} que est√° funcionando em um dado momento
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Algoritmo de elei√ß√£o --- ``Bully''}

  \begin{block}{Princ√≠pio}
    Considere $N$ processos $\{P_0, \ldots, P_{N-1}\}$ e seja $id(P_k)=k$. Quando um processo $P_k$ perceber que o coordenador n√£o est√° mais respondendo √†s requisi√ß√µes, ele come√ßa uma nova elei√ß√£o:
    \begin{enumerate}
    \item $P_k$ envia uma mensagem \texttt{ELECTION} para todos os processos com identificadores maiores que o seu: $P_{k+1}, P_{k+2}, \ldots, P_{N-1}$.
    \item Se ningu√©m responder, $P_k$ ganha a elei√ß√£o e se torna o coordenador
    \item Se um dos n√≥s com maior id responder, esse assume\footnote{O maior sempre ganha, por isso o nome de ``algoritmo do valent√£o''. \fontspec{DejaVu Sans}üòú} a elei√ß√£o e o trabalho de $P_k$ termina.
    \end{enumerate}
  \end{block}

\end{frame}

\begin{frame}
  \frametitle{Algoritmo de elei√ß√£o --- ``Bully''}

  \begin{figure}
    \centering
    \includegraphics[width=\textwidth]{06-20}
  \end{figure}

\end{frame}

\begin{frame}
  \frametitle{Algoritmo de elei√ß√£o --- ``Bully''}
  \begin{figure}
    \centering
    \includegraphics[scale=0.5]{06-20}
  \end{figure}

  \begin{alertblock}{Cuidado}
    Estamos assumido algo importante aqui. O qu√™? \pause \newline
    Assumimos que a comunica√ß√£o √© \alert{confi√°vel}
  \end{alertblock}

\end{frame}

\begin{frame}
  \frametitle{Elei√ß√£o em um anel}
  \begin{block}{Princ√≠pio}
    As prioridades dos processos s√£o obtidas organizando-os em um anel
    (l√≥gico). Processos com prioridade mais alta devem ser eleitos
    como coordenador.
  \end{block}

  \begin{itemize}
  \item qualquer processo pode iniciar a elei√ß√£o ao enviar uma
    mensagem de elei√ß√£o ao seu sucessor. Se um sucessor estiver
    indispon√≠vel, a mensagem √© enviada ao pr√≥ximo sucessor
  \item se uma mensagem for repassada, o remetente se adiciona na
    lista. Quando a mensagem voltar ao n√≥ que iniciou, todos tiveram a
    chance de anunciar a sua presen√ßa
  \item o n√≥ que iniciou circula uma mensagem pelo anel com a lista de
    n√≥s ``vivos''. O processo com maior prioridade √© eleito
    coordenador
  \end{itemize}

\end{frame}

\begin{frame}
  \frametitle{Elei√ß√£o em um anel}

    \begin{figure}
      \centering
      \includegraphics[width=\textwidth]{06-21}
    \end{figure}

    \begin{itemize}
    \item As linhas cont√≠guas mostram as mensagens da elei√ß√£o iniciada por $P_6$
    \item As linhas pontilhadas se referem a elei√ß√£o iniciada por $P_3$
    \end{itemize}

\end{frame}

\begin{frame}
  \frametitle{Elei√ß√£o de um superpeer}
  Como escolher um n√≥ para ser um \alert{superpeer} de forma que:

  \begin{itemize}
  \item n√≥s normais acessem o superpeer com pouca lat√™ncia
  \item superpeers sejam distribu√≠dos homogeneamente por toda a rede de \textit{overlay}
  \item seja mantida uma fra√ß√£o pr√©-definida de superpeers em rela√ß√£o ao n√∫mero total de n√≥s
  \item cada superpeer n√£o deve ter que servir a mais de um n√∫mero fixo de n√≥s normais
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Elei√ß√£o de um superpeer}

  \begin{block}{DHTs}
    Reserve uma parte do espa√ßo de IDs para os superpeers. \textbf{Exemplo:} se $S$ superpeers s√£o necess√°rios em um sistema que usa identificadores de $m$-bits, reserve os $k = \lceil \log_2 S \rceil$ bits mais √† esquerda para os superpeers. Em um sistema com $N$ n√≥s, teremos, em m√©dia, $2^{k-m}N$ superpeers.
  \end{block}

  \begin{block}{Roteamento para superpeers}
    Envie uma mensagem para a chave $p$ para o n√≥ respons√°vel por $p \mbox{\ AND\ } \underbrace{11 \cdots 11}_k \underbrace{00 \cdots 00}_{m-k}$.
  \end{block}
\end{frame}

\section{Sistemas de localiza√ß√£o}

\begin{frame}
  \frametitle{Posicionamento dos n√≥s}
  \begin{block}{Problema:}
    Em um sistema distribu√≠do de grande escala onde os n√≥s est√£o
    dispersados ao longo de uma rede de √°rea ampla (\textit{wide-area
      network}), frequentemente precisamos levar em considera√ß√£o as
    no√ß√µes de \alert{proximidade} ou \alert{dist√¢ncia}. Para isso,
    precisamos determinar a \alert{localiza√ß√£o} (relativa) de um n√≥.
  \end{block}

\end{frame}

\begin{frame}
  \frametitle{C√°lculo da posi√ß√£o}
  \begin{block}{Observa√ß√£o}
    Um n√≥ $P$ precisa de $d+1$ pontos de refer√™ncia para calcular sua posi√ß√£o em um espa√ßo $d$-dimensional. Considere o caso bidimensional:
  \end{block}
  \begin{columns}
    \begin{column}{.4\textwidth}
      \includegraphics[width=\textwidth]{06-18}
    \end{column}
    \quad
    \begin{column}{.4\textwidth}
      \begin{block}{Solu√ß√£o:}
        $P$ precisa resolver um sistema de tr√™s equa√ß√µes com duas inc√≥gnitas $(x_P,y_P)$:
        \[ d_i = \sqrt{(x_i-x_P)^2+(y_i-y_P)^2} \]
      \end{block}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}
  \frametitle{Sistema de posicionamento global}
  \begin{block}{Problema}
    Mesmo assumindo que os rel√≥gios dos sat√©lites s√£o precisos e est√£o sincronizados:
    \begin{itemize}
    \item leva algum tempo at√© que o sinal chegue ao receptor
    \item o rel√≥gio do receptor pode estar totalmente descompassado em rela√ß√£o ao sat√©lite
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}
  \frametitle{Sistema de posicionamento global}

  \begin{itemize}
  \item \alert{$\Delta_r$}: \alert{defasagem desconhecida} do rel√≥gio do receptor
  \item \alert{$x_r$}, \alert{$y_r$}, \alert{$z_r$}: \alert{coordenadas desconhecidas} do receptor
  \item $T_i$: timestamp da mensagem do sat√©lite $i$
  \item $\Delta_i = (T_{agora} - T_i) + \alert{\Delta_r}$: \emph{atraso medido} da mensagem enviada pelo sat√©lite $i$.
  \item \emph{dist√¢ncia \textbf{medida}} do sat√©lite $i$: $c \times \Delta_i$
    \newline ($c$ √© a velocidade da luz)
  \item A dist√¢ncia \textbf{real} √©:\\
    \[d_i=(T_{agora}- T_i) \times c\]
    logo:
    \[ \alert{d_i} = c \Delta_i - c \alert{\Delta_r} = \sqrt{(x_i - \alert{x_r})^2 + (y_i - \alert{y_r})^2 + (z_i - \alert{z_r})^2}\]

  \end{itemize}

  \begin{block}{Observa√ß√£o}
    4 sat√©lites $\Rightarrow$ 4 equa√ß√µes com 4 inc√≥gnitas (\alert{$\Delta_r$} sendo uma delas)
  \end{block}

\end{frame}

\begin{frame}
  \frametitle{Servi√ßos de posicionamento via WiFi}
  \begin{block}{Ideia b√°sica}
    \begin{itemize}
    \item Assuma a exist√™ncia de um banco de dados com as coordenadas de \textit{access points} (APs) conhecidos
    \item Assuma que podemos estimar a dist√¢ncia at√© um AP
    \item Ent√£o: com tr√™s APs detectados, podemos calcular uma posi√ß√£o
    \end{itemize}
  \end{block}
  \begin{block}{Wardriving: localizando os pontos de acesso}
    \begin{itemize}
    \item Use um dispositivo WiFi com um receptor GPS e se mova ao longo de uma √°rea enquanto grava os pontos de acesso
    \item Calcule o centroide: assuma que um ponto de acesso AP foi detectado em $N$ locais diferentes $\{\vec{x_1}, \vec{x_2}, \ldots, \vec{x_N}  \}$ (cujas coordenadas foram capturadas com o GPS)
    \item Calcule a localiza√ß√£o do AP como sendo $\vec{X_{AP}} = \frac{\sum_{i=1}^{N} \vec{x_i}}{N}$.
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}
  \frametitle{Servi√ßos de posicionamento via WiFi}
  \begin{block}{Problemas:}
    \begin{itemize}
    \item acur√°cia de cada ponto $\vec{x_i}$ detectado pelo GPS
    \item um \textit{access point} tem uma faixa de transmiss√£o que n√£o √© uniforme
    \item o n√∫mero de pontos da amostra ($N$) pode ser muito pequeno
    \end{itemize}
  \end{block}
\end{frame}

% \begin{frame}
%   \frametitle{Exemplos de aplica√ß√£o}
%   \begin{description}
%   \item[Dissemina√ß√£o de dados] talvez o exemplo mais importante;
%   \item[Agrega√ß√£o] seja $P_i$ um n√≥ que armazena uma vari√°vel $v_i$. Quando dois n√≥s se encontrarem, os dois redefinem suas vari√°veis para
%     \[ v_i,v_j \leftarrow (v_i + v_j)/2 \]
%     Resultado: no final, cada n√≥ ter√° computado a m√©dia aritm√©tica $\overline{v} = \sum_i v_i/N$
%     \begin{itemize}
%     \item O que acontece se os valores forem inicializados com $v_i=1$ e $v_j=0, j \ne i$?
%     \end{itemize}
%   \end{description}
% \end{frame}




\end{document}
